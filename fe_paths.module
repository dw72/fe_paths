<?php
/**
 * @file
 * Contains functions for the File Entity Paths module.
 */

/**
 * Implements hook_permission().
 */
function fe_paths_permission() {
  return array(
    'administer_fe_paths' => array(
      'title' => t('Administer File Entity Paths'),
      'description' => t('Adminsiter File Entity Paths configuration.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function fe_paths_menu() {
  $items['admin/config/media/fe-paths'] = array(
    'title' => 'File Entity Paths settings',
    'description' => t('Configure custom paths for file entities'),
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer_fe_paths'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fe_paths_admin_form'),
    'file' => 'fe_paths.admin.inc',
    'file path' => drupal_get_path('module', 'fe_paths') . '/includes',
  );
  $items['admin/config/media/fe-paths/global'] = array(
    'title' => 'Global',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );
  $items['admin/config/media/fe-paths/add'] = array(
    'title' => 'Add config',
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer_fe_paths'),
    'page arguments' => array('fe_paths_entity_edit_form'),
  );
  return $items;
}

/**
 * Get all variables defined by File Entity Paths
 *
 * @param $file_type
 *   The bundle name of file, eg. image, application
 *
 * @return $settings
 *   An array of variables.If $file_type set, only returns the settings of
 *   $file_type
 */
function fe_paths_get_settings($file_type = NULL) {
  $settings = &drupal_static(__FUNCTION__);

  if (!isset($settings[$file_type])) {
    $entity_info = entity_get_info('file');
    foreach ($entity_info['bundles'] as $type => $bundle_info) {
      $defaults = array();
      if (isset($bundle_info['admin'])) {
        foreach (file_get_stream_wrappers() as $scheme => $wrapper) {
          $defaults[$scheme] = array(
            'path' => '',
            'filename' => '[file:name-only-original].[file:extension-original]',
          );
        }
        $settings[$type] = variable_get("fep_$type", $defaults);
      }
    }
  }

  return is_null($file_type) ? $settings : $settings[$file_type];
}

/**
 * Implements hook_file_presave().
 */
function fe_paths_entity_presave($entity, $type) {
  // Store original filename in the database.
  if ($type == 'file' && empty($entity->origname)) {
    $entity->origname = $entity->filename;
    fe_paths_file_process($entity);
  }

}

/**
 * Actually processes the files.
 * @see fe_paths_file_presave().
 * @see fe_paths_move_files().
 */
function fe_paths_file_process($file, $parent = NULL) {
  // Get a static of processed files to prevent infinite processing.
  $processed = &drupal_static(__FUNCTION__, array());

  // Only work on local files, that have not been processed, and that already have a file_entity type.
  if (file_entity_file_is_local($file) && !array_key_exists($file->origname, $processed) && isset($file->type)) {
    $settings = fe_paths_get_settings($file->type);
    $scheme = file_uri_scheme($file->uri);
    $private = $scheme == 'private' ? TRUE : FALSE;
    $old_dir_uri = str_replace('/' . $file->filename, '', $file->uri);

    $replace_path = $settings[$scheme]['path'];
    $replace_filename = $settings[$scheme]['filename'];

    // First process tokens
    $path = token_replace($replace_path, array('file' => $file, 'file'), array('clear' => TRUE));
    $filename = token_replace($replace_filename, array('file' => $file, 'file'), array('clear' => TRUE));

    $paths = $path != '' ? explode('/', $path) : NULL;

    $new_uri = $scheme . '://' . $path . $filename;
    // Move the files, if necessary
    if ($file->uri != $new_uri) {
      $directory = $scheme . '://' . $path;
      drupal_register_shutdown_function('fe_paths_move_files', $directory, $file, $new_uri, $filename, $old_dir_uri);
    }
    $processed[$file->origname] = TRUE;
  }
}

/**
 * A function that can be called in the page shutdown to actually move files. Not safe against recursion.
 */
function fe_paths_move_files($directory, $file, $new_uri, $filename, $old_dir_uri) {
  // Create directory, if necessary.
  file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
  if (file_move($file, $new_uri)) {
    // Because of file_move works with a cloned $file object, need to update
    // this $file object.
    $file->filename = $filename;
    $file->uri = $new_uri;

    // Check, if directory is empty, and delete it, if yes
    $files = file_scan_directory($old_dir_uri, '/.*/');
    if (file_exists($old_dir_uri) && empty($files)) {
      drupal_rmdir($old_dir_uri);
     }
   }
 }

/**
 * Implements hook_token_info().
 */
function fe_paths_token_info() {
  $info['tokens']['file']['name-only'] = array(
    'name' => t("File name"),
    'description' => t("File name without extension."),
  );
  $info['tokens']['file']['name-only-original'] = array(
    'name' => t("File name - original"),
    'description' => t("File name without extension - original."),
  );
  $info['tokens']['file']['extension-original'] = array(
    'name' => t("File extension - original"),
    'description' => t("File extension - original."),
  );

  return $info;
}

/**
 * Implements hook_tokens().
 */
function fe_paths_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $url_options = array('absolute' => TRUE);
  if (isset($language)) {
    $url_options['language'] = $language;
  }
  $sanitize = !empty($options['sanitize']);

  $replacements = array();

  if ($type == 'file' && !empty($data['file'])) {
    $file = $data['file'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'name-only':
          $info = pathinfo($file->filename);
          $replacements[$original] = $info['filename'];
          break;

        case 'name-only-original':
          $info = pathinfo($file->origname);
          $replacements[$original] = $info['filename'];
          break;

        case 'extension-original':
          $info = pathinfo($file->origname);
          // Devel themer provides files with no extensions. @todo: test how
          // will this work.
          $replacements[$original] = isset($info['extension']) ? $info['extension'] : '';
          break;
      }
    }
  }

  return $replacements;
}

function fe_paths_entity_info() {
  $return = array(
    'fe_paths_config' => array(
      'label' => t('File entity paths configuration'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIControllerExportable',
      'base table' => 'fe_paths_config',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'id',
        'name' => 'machine_name',
        'label' => 'label',
      ),
      'module' => 'fe_paths',
      'exportable' => TRUE,
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
    ),
  );

  if (module_exists('entitycache')) {
    $return['fe_paths_config']['entity cache'] = TRUE;
  }

  return $return;
}

/**
 * Implements hook_form_alter().
 */
function fe_paths_form_alter(&$form, &$form_state, $form_id) {

}

/**
 * Check, if machine name of settings is exists.
 *
 * @param $machine_name
 *   The machine name to check
 *
 * @return mixed
 *  The number of rows, in which the machine name is being. Normally it could
 *  be 0 or 1.
 */
function fe_paths_check_machine_name($machine_name) {
  return db_select('fe_paths_config', 'fe')
    ->fields('fe', array('machine_name'))
    ->condition('machine_name', $machine_name)
    ->execute()
    ->rowCount();
}

/**
 * Load multiple File Entity Paths config entities based on certain conditions.
 *
 * @param $ids
 *   An array of entity IDs.
 *   If $ids contains 'all', every config will be loaded.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   An array of File Entity Paths config object objects, indexed by id.
 */
function fe_paths_config_load_multiple($ids = array('all'), $conditions = array(), $reset = FALSE) {
  if (in_array('all', $ids)) {
    $ids = db_select('fe_paths_config', 'fe')
      ->fields('fe', array('id'))
      ->execute()
      ->fetchField();
  }
  return entity_load('fe_paths_config', $ids, $conditions, $reset);
}

/**
 * Load File Entity Paths config entity by own id.
 *
 * @param $id
 *   The id of the File Entity Paths config
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return mixed
 *   The File Entity Paths config if loaded successful else FALSE.
 */
function fe_paths_config_load($id, $reset = FALSE) {
  $object = fe_paths_config_delete_multiple(array($id), array(), $reset);
  return isset($object['id']) ? isset($object['id']) : FALSE;
}

/**
 * Delete multiple File Entity Paths config entities.
 *
 * @param $ids
 *   An array of File Entity Paths config entity IDs.
 */
function fe_paths_config_delete_multiple(array $ids) {
  return entity_delete_multiple('fe_paths_config', $ids);
}

/**
 * Delete File Entity Paths config entity.
 *
 * @param $id
 *   The File Entity Paths config entity IDs.
 */
function fe_paths_config_delete($id) {
  return fe_paths_config_delete_multiple(array($id));
}

/**
 * Save a File Entity Paths config entity.
 *
 * @param $config
 *   The configuration object or array
 *
 * @return mixed
 *   The saved entity or FALSE, if something is wrong.
 */
function fe_paths_config_save($config) {
  if (is_array($config)) {
    $config = (object) $config;
  }
  return entity_save('fe_path_config', $config);
}

function fe_paths_prepare_config(&$config) {
  $info = entity_get_info('fe_paths_config');

  foreach ($config as $key => $value) {
    if (!in_array($key, $info['schema_fields_sql']['base table'])) {
      unset($config[$key]);
    }
  }

  $config = (object) $config;
  if (!isset($config->status)) {
    $config->status = 1;
  }
  dsm(get_defined_vars());
}
