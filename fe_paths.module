<?php
/**
 * @file
 * Contains functions for the File Entity Paths module.
 */

/**
 * Implements hook_menu().
 */
function fe_paths_menu() {
  // Add Token tab to each file, if devel modul exists.
  if (module_exists('devel')) {
    $items['file/%file/token'] = array(
      'title' => 'Tokens',
      'page callback' => 'token_devel_token_object',
      'page arguments' => array('file', 1),
      'access arguments' => array('access devel information'),
      'type' => MENU_LOCAL_TASK,
      'file' => 'token.pages.inc',
      'file path' => drupal_get_path('module', 'token'),
      'weight' => 5,
    );
  }
  // Attach a "Manage file paths" tab to each file type in the same way that
  // Field UI attaches "Manage fields" and "Manage display" tabs. Note that
  // Field UI does not have to be enabled; we're just using the same IA pattern
  // here for attaching the "Manage file display" page.
  $entity_info = entity_get_info('file');
  foreach ($entity_info['bundles'] as $file_type => $bundle_info) {
    if (isset($bundle_info['admin'])) {
      // Get the base path and access.
      $path = $bundle_info['admin']['path'];
      $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
      $access += array(
        'access callback' => 'user_access',
        'access arguments' => array('administer site configuration'),
      );

      // The file type must be passed to the page callbacks. It might be
      // configured as a wildcard (multiple file types sharing the same menu
      // router path).
      $file_type_argument = isset($bundle_info['admin']['bundle argument']) ? $bundle_info['admin']['bundle argument'] : $file_type;

      // Add the 'Manage file paths' tab.
      $items["$path/file-paths"] = array(
        'title' => 'Manage file paths',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('fe_paths_admin_form', $file_type_argument),
        'type' => MENU_LOCAL_TASK,
        'weight' => 5,
        'file' => 'fe_paths.admin.inc',
        'file path' => drupal_get_path('module', 'fe_paths') . '/includes',
      ) + $access;
    }
  }
  return $items;
}

/**
 * Get all variables defined by File Entity Paths
 *
 * @param $file_type
 *   The bundle name of file, eg. image, application
 *
 * @return $settings
 *   An array of variables.If $file_type set, only returns the settings of
 *   $file_type
 */
function fe_paths_get_settings($file_type = NULL) {
  $settings = &drupal_static(__FUNCTION__);

  if (!isset($vars)) {
    $entity_info = entity_get_info('file');
    foreach ($entity_info['bundles'] as $type => $bundle_info) {
      if (isset($bundle_info['admin'])) {
        $defaults = array(
          'default' => array(
            'path' => '',
            'filename' => '[file:name-only-original].[file:extension-original]',
          ),
          'private' => array(
            'path' => '',
            'filename' => '[file:name-only-original].[file:extension-original]',
          ),
        );
        $vars = variable_get("fep_$type", $defaults);
        $settings[$type] = array(
          'default' => $vars['default'],
          'private' => $vars['private'],
        );
      }
    }
  }
  return is_null($file_type) ? $settings : $settings[$file_type];
}

function fe_paths_file_load($file) {
  fe_paths_process($file[1]);
}

function fe_paths_process(&$file) {
  // Set a drupal_static variable, to prevent multiple processing.
  $processed = &drupal_static(__FUNCTION__, FALSE);

  if (!$processed) {
    $settings = fe_paths_get_settings($file->type);
    $scheme = file_uri_scheme($file->uri);
    $private = $scheme == 'private' ? TRUE : FALSE;

    if ($private) {
      $replace_path = $settings['private']['path'];
      $replace_filename = $settings['private']['filename'];
    }
    else {
      $replace_path = $settings['default']['path'];
      $replace_filename = $settings['default']['filename'];
    }

    //First process tokens
    $path = token_replace($replace_path, array('file' => $file, 'file'), array('clear' => TRUE));
    $filename = token_replace($replace_filename, array('file' => $file, 'file'), array('clear' => TRUE));

    $paths = $path != '' ? explode('/', $path) : NULL;

    $new_uri = $scheme . '://' . $path . '/' . $filename;
    //Move the files, if necessary
    if ($file->uri != $new_uri) {
      $directory = $scheme . '://' . $path;
      file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
      // Set processed here true, to prevent another processing from file_move.
      $processed = TRUE;
      file_move($file, $new_uri);
    }
    $processed = TRUE;
  }
}

/**
 * Implements hook_token_info().
 */
function fe_paths_token_info() {
  $info['tokens']['file']['name-only'] = array(
    'name' => t("File name"),
    'description' => t("File name without extension."),
  );
  $info['tokens']['file']['name-only-original'] = array(
    'name' => t("File name - original"),
    'description' => t("File name without extension - original."),
  );
  $info['tokens']['file']['extension-original'] = array(
    'name' => t("File extension - original"),
    'description' => t("File extension - original."),
  );

  return $info;
}

/**
 * Implements hook_tokens().
 */
function fe_paths_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $url_options = array('absolute' => TRUE);
  if (isset($language)) {
    $url_options['language'] = $language;
  }
  $sanitize = !empty($options['sanitize']);

  $replacements = array();

  if ($type == 'file' && !empty($data['file'])) {
    $file = $data['file'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'name-only':
          $info = pathinfo($file->filename);
          $replacements[$original] = $info['filename'];
          break;

        case 'name-only-original':
          $info = pathinfo($file->origname);
          $replacements[$original] = $info['filename'];
          break;

        case 'extension-original':
          $info = pathinfo($file->origname);
          $replacements[$original] = $info['extension'];
          break;
      }
    }
  }
  return $replacements;
}
