<?php
/**
 * @file
 * Contains functions for the File Entity Paths module.
 */

/**
 * Implements hook_permission().
 */
function fe_paths_permission() {
  return array(
    'administer_fe_paths' => array(
      'title' => t('Administer File Entity Paths'),
      'description' => t('Adminsiter File Entity Paths configuration.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function fe_paths_menu() {
  $items['admin/config/media/fe-paths'] = array(
    'title' => 'File Entity Paths settings',
    'description' => t('Configure custom paths for file entities'),
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer_fe_paths'),
    'page callback' => 'fe_paths_global_page',
    'file' => 'fe_paths.admin.inc',
  );
  $items['admin/config/media/fe-paths/global'] = array(
    'title' => 'Global',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );
  $items['admin/config/media/fe-paths/add'] = array(
    'title' => 'Add config',
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer_fe_paths'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fe_paths_entity_edit_form'),
    'file' => 'fe_paths.admin.inc',
  );
  $items['admin/config/media/fe-paths/%fe_paths_config/edit'] = array(
    'title' => 'Edit configuration',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer_fe_paths'),
    'page callback' => 'fe_paths_config_edit_page',
    'page arguments' => array(4),
    'file' => 'fe_paths.admin.inc',
  );
  $items['admin/config/media/fe-paths/%fe_paths_config/delete'] = array(
    'title' => 'Edit configuration',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer_fe_paths'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fe_paths_config_delete_confirm', 4),
    'file' => 'fe_paths.admin.inc',
  );
  return $items;
}


/**
 * Implements hook_form_alter().
 */
function fe_paths_form_alter(&$form, &$form_state, $form_id) {
  //dsm($form_id);
}

/**
 * Implements hook_theme().
 */
function fe_paths_theme() {
  return array(
    'fe_paths_config_table' => array(
      'render element' => 'element',
      'file' => 'fe_paths.admin.inc',
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function fe_paths_entity_info() {
  $return = array(
    'fe_paths_config' => array(
      'label' => t('File entity paths configuration'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIControllerExportable',
      'base table' => 'fe_paths_config',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'id',
        'name' => 'machine_name',
        'label' => 'label',
      ),
      'module' => 'fe_paths',
      'exportable' => TRUE,
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
    ),
  );

  if (module_exists('entitycache')) {
    $return['fe_paths_config']['entity cache'] = TRUE;
  }

  return $return;
}

/**
 * Implements hook_file_presave().
 */
function fe_paths_entity_presave($entity, $type) {
  if ($type == 'file') {
    // Store original filename in the database.
    if (empty($entity->origname)) {
      $entity->origname = $entity->filename;
    }
  }
  elseif (!isset($entity->fe_paths_processed) && array_key_exists($type, fe_paths_get_fieldable_entities())) {
    $entity_info = entity_get_info($type);
    // Get all fields of the saved entity.
    $fields = field_info_instances($type, $entity->{$entity_info['bundle keys']['bundle']});
    // Get all allowed widgets, which need to be processed
    $allowed_types = fe_paths_get_allowed_widget_types($entity);
    // Let's collect all processable fields, and add it to register_shutdown
    // for processing.
    foreach ($fields as $field) {
      if (in_array($field['widget']['type'], $allowed_types) && $files = field_get_items($type, $entity, $field['field_name'])) {
        foreach ($files as $file) {
          // Just for testing, in _registershutdown hard to debug.
          fe_paths_file_process(file_load($file['fid']), $entity, $type);
          //drupal_register_shutdown_function('fe_paths_file_process', $entity);
        }
      }
    }
    $entity->fe_paths_processed = TRUE;
  }
}

/**
 * Implements hook_file_delete().
 */
function fe_paths_file_delete($file) {
  fe_paths_usage_delete($file->fid);
}

/********************************
 *    Main process functions    *
 ********************************/

/**
 * Actually pre processes the files. Set a $file->fe_paths_processed flag on
 * the file entity, then add to process queue. The file will be processed
 * on drupal_register_shutdown.
 *
 * @see fe_paths_file_presave().
 * @see fe_paths_file_process().
 */
function fe_paths_file_process($file, $entity, $type) {
  if (fe_paths_file_process_available($file)) {
    $configs = fe_paths_config_load_multiple();
    $entity_info = entity_get_info($type);
    $match = FALSE;

    foreach ($configs as $config) {
      // If we have matches, no need to check more config, we have result.
      if (!empty($matches)) {
        break;
      }
      $data = $config->data;
      // First, step out, if the file types of config doesn't match.
      if (isset($data['file_entity'][$file->type]) && $data['file_entity'][$file->type] !== $file->type) {
        continue;
      }
      // If the processed entity has different type then this config, or the
      // config settings is not global skip.
      if (isset($data['entity']) && $data['entity'] != $type && $data['entity'] != 'global') {
        continue;
      }

      // Investigation of bundle settings. It's neccessary if data contains
      // bundle settings and the entity has bundle definition.
      if (isset($data['bundle']) && isset($entity_info['bundle keys']['bundle'])) {
        // Doesn't match, if the bundle value is not global, or the entity
        // has different bundle, then the settings.
        if ($data['bundle'] != 'global' && $data['bundle'] != $entity->{$entity_info['bundle keys']['bundle']}) {
          continue;
        }
      }

      $match = TRUE;
      // Store, which configuration with which entity moves the file.
      if (fe_paths_move_file($file, $config->path, $config->filename, $type, $entity)) {
        fe_paths_usage_add($file->fid, $type, $entity->{$entity_info['entity keys']['id']}, $config->id);
      };
    }
    if (!$match) {
      // If no matches, process with the default configuration.
      $settings = fe_paths_get_settings($file->type);
      $scheme = file_uri_scheme($file->uri);

      // Store, which configuration with which entity moves the file.
      if (fe_paths_move_file($file, $settings[$scheme]['path'], $settings[$scheme]['filename'], 'file')) {
        fe_paths_usage_add($file->fid, 'file', $file->fid, 0);
      }
    }
  }
}

function fe_paths_move_file($file, $replace_path, $replace_filename, $token_type, $entity = NULL) {
  $scheme = file_uri_scheme($file->uri);
  $old_dir_uri = str_replace('/' . $file->filename, '', $file->uri);

  $path = token_replace($replace_path, array(
    $token_type => $entity,
    $token_type,
    'file' => $file,
    'file'
  ), array('clear' => TRUE));

  $filename = token_replace($replace_filename, array(
    $token_type => $entity,
    $token_type,
    'file' => $file,
    'file'
  ), array('clear' => TRUE));


  $new_uri = $scheme . '://' . $path . '/' . $filename;
  $directory = $scheme . '://' . $path;

  // Create directory, if necessary.
  file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
  if (file_move($file, $new_uri)) {
    // Check, if directory is empty, and delete it, if yes
    $files = file_scan_directory($old_dir_uri, '/.*/');
    if (file_exists($old_dir_uri) && empty($files)) {
      drupal_rmdir($old_dir_uri);
    }
    // Because of file_move works with a cloned $file object, need to update
    // this $file object.
    $file->filename = $filename;
    $file->uri = $new_uri;
    return $file;
  }
  else {
    return FALSE;
  }
}

/**
 * Function to decide, if a file is available for File Entity Paths processing.
 *
 * @param $file
 *
 * @return bool
 */
function fe_paths_file_process_available($file) {
  $return = TRUE;
  // Get a static of processed files to prevent infinite processing.
  $processed = &drupal_static(__FUNCTION__, array());

  // Critical return conditions. These files never must be processed.
  if (!file_entity_file_is_local($file)) {
    return FALSE;
  }

  // @todo: is this exists in this structure? We just try it.
  if (!isset($file->type)) {
    watchdog('File Entity devel helper', t('<em>!isset($file->type)</em> condition was marked as removable in File Entity Paths module. If you still see this message in log, please let me know in <a href="http://drupal.org/node/1783934">Check whether all condition need in the fe_paths_file_process_available()</a> issue.'));
    return FALSE;
  }

  if (!array_key_exists($file->origname, $processed)) {
    $processed[$file->origname] = TRUE;
  }
  else {
    $return = FALSE;
  }
  // Clone the original file to pass as none alterable argument
  $clone = clone($file);
  // Let other modules to set $return to FALSE.
  drupal_alter('fe_paths_file_process_available', $return, $clone);
  return $return;
}

/********************************
 *       Entity functions       *
 *      (fe_paths_config)       *
 ********************************/

/**
 * Load multiple File Entity Paths config entities based on certain conditions.
 *
 * @param $ids
 *   An array of entity IDs.
 *   If $ids contains 'all', every config will be loaded.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   An array of File Entity Paths config object objects, indexed by id.
 */
function fe_paths_config_load_multiple($ids = array('all'), $conditions = array(), $reset = FALSE) {

  if (in_array('all', $ids)) {
    $ids = array();
    $result = db_select('fe_paths_config', 'fe')
      ->fields('fe', array('machine_name', 'id'))
      ->execute()
      ->fetchAllAssoc('id');
    foreach ($result as $key => $value) {
      $ids[] = $key;
    }
  }

  // Load entities
  $entities = entity_load('fe_paths_config', $ids, $conditions, $reset);

  // Prepare an empty array to short
  $weights = array();
  // Build sort index.
  foreach ($entities as $id => $config) {
    $weights[$id] = $config->weight;
  }

  asort($weights);

  // Sort entities by weight.
  $return = array();
  foreach ($weights as $key => $weight) {
    $return[$key] = $entities[$key];
  }

  return $return;
}

/**
 * Load File Entity Paths config entity by own id.
 *
 * @param $id
 *   The id of the File Entity Paths config
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return mixed
 *   The File Entity Paths config if loaded successful else FALSE.
 */
function fe_paths_config_load($id, $reset = FALSE) {
  $object = fe_paths_config_load_multiple(array($id), array(), $reset);
  return isset($object[$id]) ? $object[$id] : FALSE;
}

/**
 * Delete multiple File Entity Paths config entities.
 *
 * @param $ids
 *   An array of File Entity Paths config entity IDs.
 */
function fe_paths_config_delete_multiple(array $ids) {
  return entity_delete_multiple('fe_paths_config', $ids);
}

/**
 * Delete File Entity Paths config entity.
 *
 * @param $id
 *   The File Entity Paths config entity IDs.
 */
function fe_paths_config_delete($id) {
  return fe_paths_config_delete_multiple(array($id));
}

/**
 * Save a File Entity Paths config entity.
 *
 * @param $config
 *   The configuration object or array
 *
 * @return mixed
 *   The saved entity or FALSE, if something is wrong.
 */
function fe_paths_config_save($config) {
  if (is_array($config)) {
    $config = (object) $config;
  }

  return entity_save('fe_paths_config', $config);
}

/**
 * Prepare configuration entity to save.
 *
 * @param $config
 */
function fe_paths_prepare_config(&$config) {
  $info = entity_get_info('fe_paths_config');

  // Remove all unnecessary values from the config.
  foreach ($config as $key => $value) {
    if (!in_array($key, $info['schema_fields_sql']['base table'])) {
      unset($config[$key]);
    }
  }

  // Make an object
  $config = (object) $config;
  // Set status, if necessary.
  if (!isset($config->status)) {
    $config->status = 1;
  }
}

/********************************
 * File Entity Path usage CRUD  *
 ********************************/

/**
 * Add or update a fe_paths usage record to the database.
 *
 * @param null $fid
 * @param $entity_type
 * @param $entity_id
 * @param $id
 */
function fe_paths_usage_add($fid = NULL, $entity_type, $entity_id, $id) {
  $data = array(
    'fid' => $fid,
    'entity_type' => $entity_type,
    'entity_id' => $entity_id,
    'id' => $id,
  );


  if (!fe_paths_usage($fid)) {
    drupal_write_record('fe_paths_usage', $data);
  }

  else {
    db_update('fe_paths_usage')
      ->fields(
        array(
          'entity_type' => $entity_type,
          'entity_id' => $entity_id,
          'id' => $id,
        )
      )
      ->condition('fid', $fid)
      ->execute();
  }
}

/**
 * Delete a record from the fe_paths_usage table.
 * @param $fid
 *
 * @return DatabaseStatementInterface
 */
function fe_paths_usage_delete($fid) {
  db_delete('fe_paths_usage')
    ->condition('fid', $fid)
    ->execute();
}

/**
 * Get a file File Entity Paths configuration usage. It determine, which
 * configuration, by which entity is applied on the file.
 *
 * @param $fid
 * @param bool $reset
 *
 * @return bool
 */
function fe_paths_usage($fid, $reset = FALSE) {
  $usage = drupal_static(__FUNCTION__);

  if (isset($usage[$fid]) && !$reset) {
    return $usage[$fid];
  }

  $result = db_select('fe_paths_usage', 'fep')
    ->fields('fep')
    ->condition('fid', $fid)
    ->execute()
    ->fetchAllAssoc('fid');

  if (!$result) {
    return FALSE;
  }
  else {
    $usage[$fid] = $result[$fid];
  }
  return $usage[$fid];
}

/********************************
 *       Helper functions       *
 ********************************/

/**
 * @param $entity
 *
 * @return array
 */
function fe_paths_get_allowed_widget_types($entity) {
  $allowed = array(
    'image_image',
    'file_file',
  );

  drupal_alter($allowed, $entity);

  return $allowed;
}

/**
 * Get all variables defined by File Entity Paths
 *
 * @param $file_type
 *   The bundle name of file, eg. image, application
 *
 * @return $settings
 *   An array of variables.If $file_type set, only returns the settings of
 *   $file_type
 */
function fe_paths_get_settings($file_type = NULL) {
  $settings = &drupal_static(__FUNCTION__);

  if (!isset($settings[$file_type])) {
    $entity_info = entity_get_info('file');
    foreach ($entity_info['bundles'] as $type => $bundle_info) {
      $defaults = array();
      if (isset($bundle_info['admin'])) {
        foreach (file_get_stream_wrappers() as $scheme => $wrapper) {
          $defaults[$scheme] = array(
            'path' => '',
            'filename' => '[file:name-only-original].[file:extension-original]',
          );
        }
        $settings[$type] = variable_get("fep_$type", $defaults);
      }
    }
  }

  return is_null($file_type) ? $settings : $settings[$file_type];
}

/**
 * Check, if machine name of settings is exists.
 *
 * @param $machine_name
 *   The machine name to check
 *
 * @return mixed
 *  The number of rows, in which the machine name is being. Normally it could
 *  be 0 or 1.
 */
function fe_paths_check_machine_name($machine_name) {
  return db_select('fe_paths_config', 'fe')
    ->fields('fe', array('machine_name'))
    ->condition('machine_name', $machine_name)
    ->execute()
    ->rowCount();
}

/**
 * Get all fieldable entities. Use to build options for form elements, or
 * check, wether the saved entity is processable by File Entity Paths.
 *
 * @return array
 *   An array of fieldable entities, keyed by machine name, value is the label.
 */
function fe_paths_get_fieldable_entities() {
  $return = array();
  foreach (entity_get_info() as $name => $entity) {
    // Only works with fieldable entities.
    if ($entity['fieldable']) {
      $return[$name] = $entity['label'];
    }
  }

  return $return;
}
